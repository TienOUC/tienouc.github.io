<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tien</title>
    <description>The truth is what it is, not what you see.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 19 Mar 2020 21:54:50 +0800</pubDate>
    <lastBuildDate>Thu, 19 Mar 2020 21:54:50 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Google search console</title>
        <description>&lt;h4 id=&quot;一什么是google-search-console&quot;&gt;一、什么是Google Search Console&lt;/h4&gt;

&lt;p&gt;  &lt;a href=&quot;https://search.google.com/search-console/welcome?hl=zh-CN&amp;amp;utm_source=about-page&quot;&gt;Search Console&lt;/a&gt; 是搜索引擎Google旗下的一款免费站长工具，类似于国内的百度资源平台和其他搜索引擎的站长平台，通过注册验证网站域名，可以直观的看到网站在搜索引擎中的一些点击展现数据，以及工具提供的其它管理性的功能，同时也能接收到搜索引擎对网站检测的一些提示或通知信息，有利于更好更优质的管理站点在搜索引擎的表现，也是每个站长和网站 &lt;code class=&quot;highlighter-rouge&quot;&gt;SEOer&lt;/code&gt; 必要的使用工具。&lt;/p&gt;

&lt;h4 id=&quot;二使用方法&quot;&gt;二、使用方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;用谷歌账号登录&lt;a href=&quot;https://search.google.com/search-console/welcome?hl=zh-CN&amp;amp;utm_source=about-page&quot;&gt;Google Search Console&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用网址前缀验证，输入网址
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbn075v0wqj31g90g5aah.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择HTML标记验证
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gbn0lnr8xej30gk0tu0ts.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将复制的元标记（meta标签）粘贴到入口文件的head标签中
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbn0wk2ptwj31ds0s0di5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待入口文件更新后，在网页端查看源码，显示步骤3中复制的元标记（meta标签）已添加到入口文件head中，此时再点击步骤3中的验证按钮 
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbn4rhk5vnj31dn0rignn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;验证成功，点击前往资源页面
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gbn0o37mhtj30lg0kht99.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进入Google Search Console管理页面，待数据更新后即可查看网站的展现数据
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbn15tr2joj31kc0u0ta1.jpg&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbn18qbhg4j31is0u0jsl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 07 Feb 2020 04:46:06 +0800</pubDate>
        <link>http://localhost:4000/2020/02/Google-Search-Console/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/02/Google-Search-Console/</guid>
        
        <category>Tools</category>
        
        
      </item>
    
      <item>
        <title>v-model原理</title>
        <description>&lt;h4 id=&quot;1v-model其实是一个语法糖本质上是如下两个操作&quot;&gt;1.v-model其实是一个语法糖，本质上是如下两个操作：&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;a)  v-bind绑定一个value属性 &lt;br /&gt;
 b)  v-on指令给当前元素绑定input事件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; v-bind:value = &quot;message&quot; v-on:input = &quot;valueChange&quot;&amp;gt;
        &amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello'
            },
            methods: {
                valueChange(event){
                    this.message = event.target.value;
                }
            }
        })
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上述methods方法可以省略，利用event事件将input监听简写

    &amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; :value = &quot;message&quot; @input = &quot;message = $event.target.value&quot;&amp;gt;
        &amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello'
            }
        })
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v-model是上述v-bind和v-on的语法糖，所以

&amp;lt;input type = &quot;text&quot; v-bind:value = &quot;message&quot; v-on:input = &quot;message = $event.target.value&quot;&amp;gt;

等同于

&amp;lt;input type = &quot;text&quot; v-model = &quot;message&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 17 Dec 2019 02:46:06 +0800</pubDate>
        <link>http://localhost:4000/2019/12/v-model%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/v-model%E5%8E%9F%E7%90%86/</guid>
        
        <category>Framework/Vue</category>
        
        
      </item>
    
      <item>
        <title>vue父子组件之间的传值</title>
        <description>&lt;h3 id=&quot;1-父组件向子组件传值&quot;&gt;1. 父组件向子组件传值&lt;/h3&gt;

&lt;h4 id=&quot;-11-第一个就是要明白怎么在父页面中向子组件中传值&quot;&gt;  1.1 第一个就是要明白怎么在父页面中向子组件中传值？&lt;/h4&gt;

&lt;p&gt;你可以给子组件传入一个静态的值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8ogdk4eofj30gq01ft8i.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但我们一般都是需要传动态的值，所以需要v-bind绑定：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8ogdyto18j30gn038747.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，你传的值可以是数字、对象、数组等等，参见vue官网。&lt;/p&gt;

&lt;h4 id=&quot;-12-第二个就是要知道如何在子组件中接受父页面传过来的值有几点需要了解&quot;&gt;  1.2 第二个就是要知道如何在子组件中接受父页面传过来的值，有几点需要了解：&lt;/h4&gt;

&lt;p&gt;组件实例的作用域是孤立的；&lt;/p&gt;

&lt;p&gt;子组件要显式的用props选项声明它预期的数据，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 某个子组件中：
export default {
  props: {
    title: {
      type: String,
      default: 'hello world'
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后就可以在页面中使用了，具体我们在项目中体现。&lt;/p&gt;

&lt;p&gt;以上就是单向数据流的一般表现了： &lt;strong&gt;父级 prop 的更新会向下流动到子组件中，但是反过来则不行。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-子组件向父组件传值&quot;&gt;2. 子组件向父组件传值&lt;/h3&gt;

&lt;p&gt;那么我们延伸一下，子组件怎么向父组件传值？&lt;/p&gt;

&lt;h4 id=&quot;-21-基本概念&quot;&gt;  2.1 基本概念&lt;/h4&gt;

&lt;p&gt;在Vue中，父子组件的关系可以总结为&lt;code class=&quot;highlighter-rouge&quot;&gt;prop&lt;/code&gt;向下传递，事件向上传递。父组件通过&lt;code class=&quot;highlighter-rouge&quot;&gt;prop&lt;/code&gt;给子组件下发数据，子组件通过&lt;code class=&quot;highlighter-rouge&quot;&gt;事件&lt;/code&gt;给父组件发送信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8ogedzh3aj306u06smx0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;props down , events up
每个Vue实例都实现了事件接口：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$on(evntName)&lt;/code&gt;监听事件；使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$emit(eventName,optionalPayload)&lt;/code&gt;触发事件。另外，父组件可以在使用子组件的地方直接用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-on&lt;/code&gt;来监听子组件触发的事件。&lt;/p&gt;

&lt;h4 id=&quot;-22-举例说明&quot;&gt;  2.2 举例说明&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;父组件在组件上定义了一个自定义事件&lt;code class=&quot;highlighter-rouge&quot;&gt;childFn&lt;/code&gt;，事件名为&lt;code class=&quot;highlighter-rouge&quot;&gt;parentFn&lt;/code&gt;用于接受子组件传过来的&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;值。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- 父组件 --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;test&quot;&amp;gt;
      &amp;lt;test-com @childFn=&quot;parentFn&quot;&amp;gt;&amp;lt;/test-com&amp;gt;
      &amp;lt;br/&amp;gt; 
      子组件传来的值 : 
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    // ...
    data: {
        message: ''
    },
    methods: {
       parentFn(payload) {
        this.message = payload;
      }
    }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;子组件是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;buttton&lt;/code&gt;按钮，并为其添加了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;click&lt;/code&gt;事件，当点击的时候使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$emit()&lt;/code&gt;触发事件，把&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;传给父组件。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- 子组件 --&amp;gt;
&amp;lt;template&amp;gt; 
&amp;lt;div class=&quot;testCom&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&amp;gt;
    &amp;lt;button @click=&quot;click&quot;&amp;gt;Send&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
    // ...
    data() {
        return {
          // 默认
          message: '我是来自子组件的消息'
        }
    },
    methods: {
      click() {
            this.$emit('childFn', this.message);
        }
    }    
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样我们就基本实现了子组件向父组件发送值了。&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Nov 2019 17:28:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</guid>
        
        <category>WEB/Framework</category>
        
        
      </item>
    
      <item>
        <title>create-react-app部署项目到Github Pages</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://willtien.com/Account-app/&quot;&gt;账单薄项目预览&lt;/a&gt; &lt;br /&gt;
mockAPI: &lt;a href=&quot;https://5db85da7177b350014ac796d.mockapi.io/api/v1/records&quot;&gt;API endpoint&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-创建项目&quot;&gt;&lt;strong&gt;1. 创建项目&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;使用 create-react-app 脚手架创建项目&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install create-react-app 
npm create-react-app my-app
cd my-app
npm start  // 运行

npm run eject //解压默认webpack包，操作不可逆
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-将本地的文件-push-至远端仓库&quot;&gt;&lt;strong&gt;2. 将本地的文件 push 至远端仓库&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git init         // 初始化一个文件夹为本地仓库
git status    // 查看状态和是否存在.git文件
git add .      // 添加到暂存区
git commit -m '提交'            // 提交到版本库且增添提交备注
git remote add origin {url}   // {url} 是你的GitHub上reponsitory地址
git push -u origin master     // 将代码推送到GitHub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-github-pages-部署&quot;&gt;&lt;strong&gt;3. Github Pages 部署&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;把项目部署成GitHub pages，在GitHub上点开项目到设置，翻到Github Pages设置处，可以看到GitHub Pages只能使用master、gh-pages分支或者master下面的docs文件夹。
这里使用的是gh-pages分支的方式来创建&lt;/p&gt;

&lt;h4 id=&quot;4-安装-gh-pages&quot;&gt;&lt;strong&gt;4. 安装 gh-pages&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install gh-pages --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 gh-pages 中间件，可以把 build 文件下的文件推送到 GitHub，并且创建 gh-pages branch&lt;/p&gt;

&lt;h4 id=&quot;5-修改-packagejson&quot;&gt;&lt;strong&gt;5. 修改 package.json&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;name&quot;: &quot;react_demo&quot;,
    &quot;version&quot;: &quot;1.1.0&quot;,
    &quot;private&quot;: true,
  + &quot;homepage&quot;: &quot;./&quot;,  // 表示你访问的页面
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;注意：homepage 不要设置成 github page上生成的那个链接路径，比如https://username.github.io/react_demo/。如果设置成上面的连接，build打的包会这所有路径前面加上react_demo。比如 index.html 文件中对同等目录下的文件引用应该是 src=’./index.css’，结果会变成src=’./react_demo/index.css’，这样部署后肯定无法访问，所有资源都找不到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;增加npm scripts命令，推送gh-pages&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;scripts&quot;: {
        ...
  + &quot;predeploy&quot;: &quot;npm run build&quot; , // 将你的项目预编译成静态文件放在build文件夹
  + &quot;deploy&quot;: &quot;gh-pages -d build&quot;  // 是使用gh-pages 部署你的build文件夹下的内容
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意修改之后注意也 push 上去&lt;/p&gt;
&lt;h4 id=&quot;6-推送项目&quot;&gt;&lt;strong&gt;6. 推送项目&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;GitHub Pages只是部署项目，react代码直接放上去是识别不了的，所以部署的是打包编译后到代码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run build&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Webpack 4.X打包Bootstrap4.x失败解决办法&lt;/strong&gt;&lt;/p&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install jquery --save // Bootstrap4.x 依赖JQuery，所以需要先安装JQuery
npm install popper.js --save // Bootstrap4.x 依赖Popper，所以需要先安装Popper
npm install bootstrap --save // 安装Bootstrap4.x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;编译后就可以推送了,执行上面配置的命令。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run deploy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这时github上项目就多出了一个gh-pages的branch，在设置中Github Pages处选择gh-pages分支保存，部署完成。
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8hni5w4moj30kf0gm0t6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;部署时候具体执行的操作大概为：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;按照 package.json 里面增加配置代码&lt;/li&gt;
  &lt;li&gt;build 打包编译代码文件&lt;/li&gt;
  &lt;li&gt;使用 gh-pages 工具把 build 文件下的文件推送到 GitHub部署到新的gh-pages分支上&lt;/li&gt;
  &lt;li&gt;发布页面&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 30 Oct 2019 01:00:06 +0800</pubDate>
        <link>http://localhost:4000/2019/10/create-react-app%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0Github-Pages/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/create-react-app%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0Github-Pages/</guid>
        
        <category>Tools</category>
        
        
      </item>
    
      <item>
        <title>TCP和UDP的简单理解</title>
        <description>&lt;h4 id=&quot;1-tcp-和-udp-的区别&quot;&gt;1. TCP 和 UDP 的区别&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;TCP 是面向连接的，UDP 是面向无连接的&lt;/li&gt;
  &lt;li&gt;UDP程序结构较简单&lt;/li&gt;
  &lt;li&gt;TCP 是面向字节流的，UDP 是基于数据报的&lt;/li&gt;
  &lt;li&gt;TCP 保证数据正确性，UDP 可能丢包&lt;/li&gt;
  &lt;li&gt;TCP 保证数据顺序，UDP 不保证&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-什么是面向连接什么是面向无连接&quot;&gt;2. 什么是面向连接，什么是面向无连接?&lt;/h4&gt;

&lt;p&gt;在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会&lt;/p&gt;

&lt;h4 id=&quot;3-tcp三次握手&quot;&gt;3. TCP三次握手?&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.客户端发起请求（寻址请求） &lt;br /&gt;
2.服务端收到请求，然后回应请求（确认请求） &lt;br /&gt;
3.客户端收到服务端的回应报文并对服务端作出回应（连接请求）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;简单理解：A代表客户端，B代表服务端
A: 你好，我是A
B: 你好，我是B
A: 你好B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4-tcp四次挥手&quot;&gt;4. TCP四次挥手?&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.数据验证请求码 &lt;br /&gt;
2.传输结束标记 &lt;br /&gt;
3.确认结束标记 &lt;br /&gt;
4.连接断开标记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A：B 啊，我不想玩了
B：哦，你不想玩了啊，我知道了【 这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。】
B：A 啊，结束了，我也不玩了，拜拜
A：好的，拜拜
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;5-tcp-为什么是可靠连接&quot;&gt;5. TCP 为什么是可靠连接?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达；&lt;/li&gt;
  &lt;li&gt;TCP 报文头里面的序号能使 TCP 的数据按序到达；&lt;/li&gt;
  &lt;li&gt;报文头里面的确认序号能保证不丢包，累计确认及超时重传机制；&lt;/li&gt;
  &lt;li&gt;TCP 拥有流量控制及拥塞控制的机制；&lt;/li&gt;
  &lt;li&gt;TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的；&lt;/li&gt;
  &lt;li&gt;拥塞控制时通过拥塞窗口来解决的。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;UDP报文结构:
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g88cm2eqlvj30sw07yjr9.jpg&quot; alt=&quot;UDP报文结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP报文结构:
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g88cm20bzaj30rs0d9jri.jpg&quot; alt=&quot;TCP报文结构&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Oct 2019 01:00:06 +0800</pubDate>
        <link>http://localhost:4000/2019/10/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
        
        <category>WEB</category>
        
        
      </item>
    
      <item>
        <title>隐式类型转换的妙用</title>
        <description>&lt;h4 id=&quot;可变数组求和举例&quot;&gt;可变数组求和举例&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(...a){
var sum = 0
a.forEach((item) =&amp;gt; {
    sum += item  
})
return sum 
}
console.log(foo(1,2,3,'4',11))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt;&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Running] node &quot;Untitled-1.js&quot;
6411
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;hr /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(...a){
var sum = 0
a.forEach((item) =&amp;gt; {
    sum += item * 1   // *1 隐式类型转换,把'4' 转换成4
})
return sum 
}
console.log(foo(1,2,3,'4',11))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt;&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Running] node &quot;Untitled-1.js&quot;
21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 19 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%A6%99%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%A6%99%E7%94%A8/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>跨域及几种解决方法</title>
        <description>&lt;h4 id=&quot;一-什么是跨域&quot;&gt;一、 &lt;strong&gt;什么是跨域&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。&lt;/p&gt;

&lt;p&gt;例如：a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;&lt;em&gt;同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;二-解决跨域的几种方法&quot;&gt;二、 &lt;strong&gt;解决跨域的几种方法&lt;/strong&gt;&lt;/h4&gt;

&lt;h5 id=&quot;21-jsonp&quot;&gt;2.1 JSONP&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; 动态创建一个script标签，动态加载一个js文件，载入成功之后会执行在url参数中指定的函数，并且把需要的json数据所谓参数传入。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;&lt;em&gt;只能传递get请求，有一定的限制&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 原生方法
(function (window,document) {
    &quot;use strict&quot;;
    var jsonp = function (url,data,callback) {

        // 1.将传入的data数据转化为url字符串形式
        // {id:1,name:'zhangsan'} =&amp;gt; id=1&amp;amp;name=zhangsan
        var dataString = url.indexof('?') == -1? '?': '&amp;amp;';
        for(var key in data){
            dataString += key + '=' + data[key] + '&amp;amp;';
        };

        // 2 处理url中的回调函数
        // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）
        var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.','');
        dataString += 'callback=' + cbFuncName;

        // 3.创建一个script标签并插入到页面中
        var scriptEle = document.createElement('script');
        scriptEle.src = url + dataString;

        // 4.挂载回调函数
        window[cbFuncName] = function (data) {
            callback(data);
            // 处理完回调函数的数据之后，删除jsonp的script标签
            document.body.removeChild(scriptEle);
        }

        // 5.append到页面中
        document.body.appendChild(scriptEle);
    }

    // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作为window对象的一个方法，供外部调用
    window.$jsonp = jsonp;

})(window,document)

// 原生方式精简版
&amp;lt;script&amp;gt;
    var script = document.createElement('script');
    script.type = 'text/javascript';
 
    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.baidu.com/xx?a=b&amp;amp;callback=onBack';
    document.head.appendChild(script);
 
    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
&amp;lt;/script&amp;gt;


// jQuery
$.ajax({
    url: url,
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: &quot;callback&quot;,    // 自定义回调函数名
    data: {}
});

// 后端node.js代码
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();
 
server.on('request', function(req, res) {
    var params = qs.parse(req.url.split('?')[1]);
    var fn = params.callback;
 
    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');
 
    res.end();
});
 
server.listen('8080');
console.log('Server is running at port 8080...');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;22-cros跨域资源共享&quot;&gt;2.2 CROS跨域资源共享&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; 服务器端对于cros的支持，设置Access-Control-Allow-Origin为你传输的origin的值，浏览器监测到响应的设置，支持跨域&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;&lt;em&gt;跨域携带cookies&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;&lt;em&gt;优缺点：支持所有的请求类型，get、post、put、delete、updata等等&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;&lt;em&gt;所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 原生
...
xhr.withCredentials = true
...

// jQuery
$.ajax({
    ...
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
    ...
});

// axios
axios.defaults.withCredentials=true; // 让ajax携带cookie

//服务端设置
const app = express()
app.all('*', function(req, res, next) {
  res.header('Access-Control-Allow-Origin', '*') // 访问控制允许来源：所有
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept') // 访问控制允许报头 X-Requested-With: xhr请求
  res.header('Access-Control-Allow-Metheds', 'PUT, POST, GET, DELETE, OPTIONS') // 访问控制允许方法
  res.header('X-Powered-By', 'nodejs') // 自定义头信息，表示服务端用nodejs
  res.header('Content-Type', 'application/json;charset=utf-8')
  res.header('Access-Control-Max-Age', '600')
  next()
})

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;23-windowname--iframe跨域&quot;&gt;2.3 window.name + iframe跨域&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; 一般用于iframe的跨域问题，在一个窗口（window）的生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面的window.name都有读写的权限，并且是持久存在一个再如果的所有页面中&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;&lt;em&gt;优缺点：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。window.name支持非常长的name值(2MB)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在A页面设置函数

var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');
 
    // 加载跨域页面
    iframe.src = url;
 
    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();
 
        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };
 
    document.body.appendChild(iframe);
 
    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};
 
// 请求跨域b页面数据
proxy('http://www.xxx.com/B.html', function(data){
    alert(data);
});


// 在B页面设置window.name值
&amp;lt;script&amp;gt;
    window.name = 'B页面向A页面传递的数据';
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;24-h5属性-windowpostmessage&quot;&gt;2.4 H5属性 window.postMessage&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;页面和其打开的新窗口的数据传递&lt;/li&gt;
    &lt;li&gt;多窗口之间消息传递&lt;/li&gt;
    &lt;li&gt;页面与嵌套的iframe消息传递&lt;/li&gt;
    &lt;li&gt;上面三个场景的跨域数据传递&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;用法：postMessage(data,origin)方法接受两个参数
data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // A页面 
&amp;lt;iframe id=&quot;iframe&quot; src=&quot;http://www.B.com/b.html&quot; style=&quot;display:none;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;      
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            msg: 'xxx'
        };
        // 向B传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.B.com');
    };
 
    // 接受B返回数据
    window.addEventListener('message', function(e) {
        alert('data from B ---&amp;gt; ' + e.data);
    }, false);
&amp;lt;/script&amp;gt;


// B页面
&amp;lt;script&amp;gt;
    // 接收A的数据
    window.addEventListener('message', function(e) {
        alert('data from A ---&amp;gt; ' + e.data);
 
        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;
 
            // 处理后再发回A
            window.parent.postMessage(JSON.stringify(data), 'http://www.A.com');
        }
    }, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;21-nodejs中间件代理跨域&quot;&gt;2.1 nodejs中间件代理跨域&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发&lt;/p&gt;

&lt;p&gt;node + vue + webpack-dev-server代理接口跨域，在开发模式下，只需要配置devServer=&amp;gt;proxy即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = {
    entry: {},
    module: {},
    ...
    devServer: {
        historyApiFallback: true,
        proxy: [{
            target: 'http://www.B.com:8080',  // 代理跨域目标接口
            changeOrigin: true,
            cookieDomainRewrite: 'www.A.com'  // 可以为false，表示不修改
        }],
        noInfo: true
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在非框架类时nodejs使用http-proxy-middleware&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();
 
app.use('/', proxy({
    // 代理跨域目标接口
    target: 'http://www.B.com:8080',
    changeOrigin: true,
 
    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.A.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },
 
    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.A.com'  // 可以为false，表示不修改
}));
 
app.listen(5566);
console.log('Proxy server is listen at port 5566...');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;nodejs如何设置允许跨域&quot;&gt;Node.js如何设置允许跨域&lt;/h3&gt;

&lt;h4 id=&quot;1-设置允许所有域名跨域&quot;&gt;1. 设置允许所有域名跨域：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all(&quot;*&quot;,function(req,res,next){
    //设置允许跨域的域名，*代表允许任意域名跨域
    res.header(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);
    //允许的header类型
    res.header(&quot;Access-Control-Allow-Headers&quot;,&quot;content-type&quot;);
    //跨域允许的请求方式 
    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;DELETE,PUT,POST,GET,OPTIONS&quot;);
    if (req.method.toLowerCase() == 'options')
        res.send(200);  //让options尝试请求快速结束
    else
        next();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-设置允许指定域名httpwwwabccom跨域&quot;&gt;2. 设置允许指定域名“http://www.ABC.com”跨域：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all(&quot;*&quot;,function(req,res,next){
    //设置允许跨域的域名，*代表允许任意域名跨域
    res.header(&quot;Access-Control-Allow-Origin&quot;,&quot;http://www.ABC.com&quot;);
    //允许的header类型
    res.header(&quot;Access-Control-Allow-Headers&quot;,&quot;content-type&quot;);
    //跨域允许的请求方式 
    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;DELETE,PUT,POST,GET,OPTIONS&quot;);
    if (req.method.toLowerCase() == 'options')
        res.send(200);  //让options尝试请求快速结束
    else
        next();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-设置允许多个域名跨域&quot;&gt;3. 设置允许多个域名跨域：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all(&quot;*&quot;,function(req,res,next){
    if( req.headers.origin.toLowerCase() == &quot;http://www.ABC.com&quot;
        || req.headers.origin.toLowerCase() ==&quot;http://127.0.0.1&quot; ) {
        //设置允许跨域的域名，*代表允许任意域名跨域
        res.header(&quot;Access-Control-Allow-Origin&quot;, req.headers.origin);
    }
    //允许的header类型
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;);
    //跨域允许的请求方式 
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;DELETE,PUT,POST,GET,OPTIONS&quot;);
    if (req.method.toLowerCase() == 'options')
        res.send(200);  //让options尝试请求快速结束
    else
        next();    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4-如果允许的域名较多可以将允许跨域的域名放到数组当中&quot;&gt;4. 如果允许的域名较多，可以将允许跨域的域名放到数组当中：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all(&quot;*&quot;,function(req,res,next){
    var orginList=[
        &quot;http://www.ABC.com&quot;,
        &quot;http://www.alibaba.com&quot;,
        &quot;http://www.qq.com&quot;,
        &quot;http://www.baidu.com&quot;
    ]
    if(orginList.includes(req.headers.origin.toLowerCase())){
        //设置允许跨域的域名，*代表允许任意域名跨域
        res.header(&quot;Access-Control-Allow-Origin&quot;,req.headers.origin);
    }
    //允许的header类型
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;);
    //跨域允许的请求方式
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;DELETE,PUT,POST,GET,OPTIONS&quot;);
    if (req.method.toLowerCase() == 'options')
        res.send(200);  //让options尝试请求快速结束
    else
        next();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 14 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
        
        <category>NodeJS</category>
        
        
      </item>
    
      <item>
        <title>MogoDB(MacOS)</title>
        <description>&lt;h4 id=&quot;一安装&quot;&gt;&lt;strong&gt;一、安装&lt;/strong&gt;&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;主要有如下三种安装方式，本文主要介绍对入门友好的第三种方式 &lt;br /&gt;
+（1）手动命令安装 &lt;br /&gt;
+（2）采用Homebrew &lt;br /&gt;
+（3）下载安装包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.mongodb.com/download-center?jmp=nav#community&quot;&gt;MongoDB Download&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将解压后的文件放入 /usr/local ，默认情况下在Finder中是看不到 /usr 这个目录的（终端用得溜的请略过），可以打开Finder后按 shift + command +G 输入 /usr/local 后回车便能看到这个隐藏的目录了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置环境变量，打开终端，输入“open -e .bash_profile”，在打开的文件中加入。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;export PATH=${PATH}:/usr/local/MongoDB/bin&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用Command+S保存配置，关闭上面的.bash_profile编辑窗口，然后在下图中输入”source .bash_profile”使配置生效。输入”mongod -version”，回车后如果看到下面的版本号则说明MongoDB已经成功安装到了Mac上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在根目录下新建 data 文件夹，里面再建一个 db 文件夹，安装MongoDB时并不会自动生成，需要我们手动创建，可以在命令行输入创建，也可以直接在Finder中手动新建。&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;如遇到找不到data/db的问题，&lt;code class=&quot;highlighter-rouge&quot;&gt;   sudo mkdir -p /data/db &lt;/code&gt; 创建路径即可，或者直接自定义路径&lt;code class=&quot;highlighter-rouge&quot;&gt;  mongod --dbpath /usr/local/mongoDB/data/db   &lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;二运行&quot;&gt;&lt;strong&gt;二、运行&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;打开命令行输入&lt;code class=&quot;highlighter-rouge&quot;&gt;   mongod&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显示等候客户端连接的界面就代表启动成功了，如果不成功就检查下 /data/db 文件夹位置对不对，不行就重新删掉建一个， 打开浏览器，输入localhost:27017 ，会出现这样一行文字。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;It looks like you are trying to access MongoDB over HTTP on the native driver port.&lt;/code&gt;      打开新的terminal，输入  &lt;code class=&quot;highlighter-rouge&quot;&gt;mongo&lt;/code&gt;    &lt;br /&gt;
可以对数据库进行操作，要停止MongoDB的时候一定要正确的退出，不然下次再次连接数据库会出现问题，使用下面的两行代码可以完成这一操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use admin;
db.shutdownServer();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;三可视化工具&quot;&gt;&lt;strong&gt;三、可视化工具&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Robot 3T是一个跨平台的MongoDB GUI客户端管理工具，支持Windows、MacOS、Linux。其特点是支持到MongoDB服务器的SSL连接，还支持使用SSH隧道连接。RoboMongo的查询界面同时支持树视图、表格视图、文本视图三种，也可以保存查询结果供以后使用。可以选择适合自己的版本下载。
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g7tjg6wbn0j312c0lndh7.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g7tjg6nfoej31290lnq3i.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;四简单应用&quot;&gt;&lt;strong&gt;四、简单应用&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;数据库插入&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/users', {useNewUrlParser: true,useUnifiedTopology: true})

var app = mongoose.connection;
app.on('error', console.error.bind(console, 'connection error:'))
app.once('open', function () {
    console.log('app is ok!')
})

//获取Schema对象
var usersSchema = new mongoose.Schema({
    us: {type: String, required: true},
    ps: {type: String, required: true},
    age: Number,
    sex: {type: Number, default: 0}
});

//将schema对象转换为数据模型
var User = mongoose.model('users', usersSchema)

//数据库--插入
User.insertMany({us:'Tien', ps:'123', age:18})
.then((data)=&amp;gt;{
    console.log(data)
    console.log('插入成功!')
})
.catch((err)=&amp;gt;{
    console.log('插入失败!')
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g7tjtym2pyj30wy0bu74d.jpg&quot; alt=&quot;数据库插入 4-1&quot; /&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g7tjtyu6s0j31oi0fot9i.jpg&quot; alt=&quot;数据库插入 4-2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库删除&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/users', {useNewUrlParser: true,useUnifiedTopology: true})

var app = mongoose.connection;
app.on('error', console.error.bind(console, 'connection error:'))
app.once('open', function () {
    console.log('app is ok!')
})

//获取Schema对象
var usersSchema = new mongoose.Schema({
    us: {type: String, required: true},
    ps: {type: String, required: true},
    age: Number,
    sex: {type: Number, default: 0}
});

//将schema对象转换为数据模型
var User = mongoose.model('users', usersSchema)

//数据库--删除
User.remove()
.then((data)=&amp;gt;{
    console.log('delete done!');
})
.catch((err)=&amp;gt;{
    console.log('删除失败！')
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g7tk0ufb45j30x00byaa1.jpg&quot; alt=&quot;数据库删除数据 4-3&quot; /&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g7tk0ungbgj31ok0gs3zd.jpg&quot; alt=&quot;数据库删除数据 4-4&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库查询&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/users', {useNewUrlParser: true,useUnifiedTopology: true})

var app = mongoose.connection;
app.on('error', console.error.bind(console, 'connection error:'))
app.once('open', function () {
    console.log('app is ok!')
})

//获取Schema对象
var usersSchema = new mongoose.Schema({
    us: {type: String, required: true},
    ps: {type: String, required: true},
    age: Number,
    sex: {type: Number, default: 0}
});

//将schema对象转换为数据模型
var User = mongoose.model('users', usersSchema)

//数据库--查询
User.find({age:18})
.then((data)=&amp;gt;{
    console.log(data)
    console.log('查询成功！')
})
.catch((err)=&amp;gt;{
    console.log('查询失败！')
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g7tk7nm5ruj30wz0c2jrh.jpg&quot; alt=&quot;数据库查询 4-5&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Oct 2019 19:45:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/MogoDB/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/MogoDB/</guid>
        
        <category>NodeJS</category>
        
        
      </item>
    
      <item>
        <title>Js一元运算-数据类型转换</title>
        <description>&lt;p&gt;今天碰到个下面这段代码中  ` =+ ` 一时半会儿不得其解，上&lt;a href=&quot;https://stackoverflow.com/questions/17106681/parseint-vs-unary-plus-when-to-use-which&quot;&gt;stack overflow&lt;/a&gt;  查了一下才知道这个是日常比较少见的数据类型转换用法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function(dx, dy){
            rect.attr({x: orig_x+dx,y: orig_y+dy, fill:&quot;orange&quot;});
        },function(x,y){
            orig_x=+rect.attr(&quot;x&quot;);
            orig_y=+rect.attr(&quot;y&quot;);
            rect.attr({fill:&quot;orange&quot;});
        },function(){
            rect.attr({fill:&quot;blue&quot;});
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这称之为正号(+)或是一元正号(unary plus)，而不是加号(+)，因为参与的运算子只会有一个，所以称为一元。&lt;/p&gt;

&lt;p&gt;简单的来说，它是一种把其他类型的资料转为数字类型的语法，可以不限于字符串。建议只用在单纯的数字字符串上。&lt;/p&gt;

&lt;p&gt;这种语法是从使用社群上发展出来的，教科书上很少会提及。这种语法有很多种，下面有张图里有6种是我从&lt;a href=&quot;https://stackoverflow.com/questions/17106681/parseint-vs-unary-plus-when-to-use-which&quot;&gt;这篇问答&lt;/a&gt;找来的，它是用&lt;a href=&quot;http://jsfiddle.net/EpUBN/8/&quot;&gt;代码产生&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image-static.segmentfault.com/178/037/1780371411-5824716d2aa3b&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看图中就大概知道，一元正号(+)的行为类似于parseFloat，而不是parseInt，相似于parseInt的是双波折号(~~)的语法。&lt;/p&gt;

&lt;p&gt;一元正号(+)可以把像”123.456”的字符串，转换为数字类型的123.456。会使用一元正号(+)，而不用parseFloat其实是有原因的，大致上简单说明一下:&lt;/p&gt;

&lt;h4 id=&quot;1-快&quot;&gt;1. 快&lt;/h4&gt;
&lt;p&gt;这种语法会被使用的主要原因，是经过测试过在某些浏览器与情况下它的效率超快。&lt;/p&gt;

&lt;h4 id=&quot;2-语法简单&quot;&gt;2. 语法简单&lt;/h4&gt;
&lt;p&gt;打个正号(+)比打parseFloat或parseInt够简单了。&lt;/p&gt;

&lt;h4 id=&quot;3-某些特殊转置情况下使用&quot;&gt;3. 某些特殊转置情况下使用&lt;/h4&gt;
&lt;p&gt;例如以下几个，有些开发者会用这些转置的结果，但建议你除非很确定要什么结果再使用。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a.空字符串/null/false: +’‘得出0数字，但用parseFloat或parseInt会得出NaN。 &lt;br /&gt;
b.科学记号: +’2e3’得2000，与parseFloat一致，parseInt会得出2。 &lt;br /&gt;
c.16进位: +’0xf’得15，parseFloat得0，parseInt会得出15。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的语法还有很多，例如1*‘123.456’或-(-‘123.456’)之类的, 总之这种就很少见, 也很少人在用了。&lt;/p&gt;

</description>
        <pubDate>Thu, 19 Sep 2019 03:15:00 +0800</pubDate>
        <link>http://localhost:4000/2019/09/Js%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/Js%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
        
        <category>Javascript</category>
        
        
      </item>
    
      <item>
        <title>gitignore忽略不必要文件</title>
        <description>&lt;p&gt;&lt;strong&gt;忽略文件的原则是：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;忽略操作系统自动生成的文件，比如缩略图等；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-先在项目路径下添加gitignore文件&quot;&gt;1. 先在项目路径下添加.gitignore文件。&lt;/h4&gt;
&lt;h4 id=&quot;2-编辑gitignore文件其实就是输入一些相对路径或者通配符来避免文件提交&quot;&gt;2. 编辑.gitignore文件，其实就是输入一些相对路径或者通配符来避免文件提交。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.DS_Store
.idea
vendor/

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 查看，可以看出排除了的文件，避免了其提交。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-github-desktop-中添加&quot;&gt;3. Github DeskTop 中添加&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g6zf27vt98j30gl07274e.jpg&quot; alt=&quot;&quot; /&gt;&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g6zf27luccj30fp0c83ym.jpg&quot; alt=&quot;&quot; /&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 15 Sep 2019 06:16:01 +0800</pubDate>
        <link>http://localhost:4000/2019/09/gitignore%E5%BF%BD%E7%95%A5%E4%B8%8D%E5%BF%85%E8%A6%81%E6%96%87%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/gitignore%E5%BF%BD%E7%95%A5%E4%B8%8D%E5%BF%85%E8%A6%81%E6%96%87%E4%BB%B6/</guid>
        
        <category>Tools</category>
        
        
      </item>
    
  </channel>
</rss>
